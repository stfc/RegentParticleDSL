import "regent"

ast = require("regent/ast")
format = require("std/format")

compute_privileges = {}

local function two_region_privilege_map(node, sym1, sym2, read_sym1, read_sym2, write_sym1, write_sym2)
  --First case - we have an assignment. If we have an assignment and the lhs is a FieldAccess, then
  --this is a written to part of our region
  if(node:is(ast.specialized.stat.Assignment)) then
    if(node.lhs[1]:is(ast.specialized.expr.FieldAccess)) then
      if(node.lhs[1].value.value == sym1) then
        write_sym1:insert(node.lhs[1].field_name)
      elseif(node.lhs[1].value.value == sym2) then
        write_sym2:insert(node.lhs[1].field_name)
      end
    end
  --Second case - For all field accesses we assume they are read from (though in some cases they are only
  --written to, I don't think that adding a read requirement should cause any issues)
  elseif(node:is(ast.specialized.expr.FieldAccess)) then
      if(node.value.value == sym1) then
        read_sym1:insert(node.field_name)
      elseif(node.value.value == sym2) then
        read_sym2:insert(node.field_name)
      end
  end
end

local function return_true(node) return true end
local function return_false(node) return false end

local is_specialized_table = {
  [ast.specialized.expr] = return_true,
  [ast.specialized.stat] = return_true,
  [ast.specialized.top] = return_true,
  [ast.specialized.Block] = return_true,
}

local is_specialized_node = ast.make_single_dispatch(is_specialized_table, {}, return_false)()

local function traverse_specialized_postorder_two_region(fn, node, sym1, sym2, read_sym1, read_sym2, write_sym1, write_sym2)
  ast.traverse_node_postorder(
    function(node)
--      if node:is(ast.specialized.expr) then
        fn(node, sym1, sym2, read_sym1, read_sym2, write_sym1, write_sym2)
--      end
    end,
    node, is_specialized_node)
end


local function traverse_specialized_postorder_one_region(fn, node, sym, read_sym, write_sym)
  ast.traverse_node_postorder(
    function(node)
      fn(node, sym, read_sym, write_sym)
    end,
    node, is_specialized_node)
end

function compute_privileges.two_region_privileges(kernel_name)
  local part1 = regentlib.newsymbol("part1")
  local part2 = regentlib.newsymbol("part2")
  local r2 = regentlib.newsymbol("r2")
--  print(kernel_name(part1, part2, r2))
--  print(kernel_name)
  local z = kernel_name(part1, part2, r2)
  local read_p1 = terralib.newlist()
  local read_p2 = terralib.newlist()
  local write_p1 = terralib.newlist()
  local write_p2 = terralib.newlist()
  traverse_specialized_postorder_two_region(  two_region_privilege_map, z.ast, part1, part2, read_p1, read_p2, write_p1, write_p2)
  local hash = {}
  local temp = terralib.newlist()
  for _,v in pairs(read_p1) do
    if( not hash[v]) then
      temp:insert(v)
      hash[v] = true
    end
  end
  read_p1 = temp
  hash = {}
  temp = terralib.newlist()
  for _,v in pairs(read_p2) do
    if( not hash[v]) then
      temp:insert(v)
      hash[v] = true
    end
  end
  read_p2 = temp
  hash = {}
  temp = terralib.newlist()
  for _,v in pairs(write_p1) do
    if( not hash[v]) then
      temp:insert(v)
      hash[v] = true
    end
  end
  write_p1 = temp
  hash = {}
  temp = terralib.newlist()
  for _,v in pairs(write_p2) do
    if( not hash[v]) then
      temp:insert(v)
      hash[v] = true
    end
  end
  write_p2 = temp
  return read_p1, read_p2, write_p1, write_p2
end




return compute_privileges
